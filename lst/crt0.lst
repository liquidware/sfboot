ARM GAS  crt0.S 			page 1


   1              	@/*****************************************************************************
   2              	@*   startup.s: startup file for NXP LPC230x Family Microprocessors
   3              	@*
   4              	@*   Copyright(C) 2006, NXP Semiconductor
   5              	@*   All rights reserved.
   6              	@*
   7              	@*   History
   8              	@*   2006.09.01  ver 1.00    Prelimnary version, first Release
   9              	@*
  10              	@*****************************************************************************/
  11              	
  12              	@ modified by Martin Thomas:
  13              	@  - changed comment char to @ for GNU assembler (arm-elf-as)
  14              	@    "The line comment character is [...] ‘@’ on the ARM [...]"
  15              	@    (GNU-as manual from binutils V 2.17)
  16              	@  - ported RV-ASM to GNU-ASM (sections, import/export equ, 
  17              	@    :OR:, Labels etc.)
  18              	@  - added .data and .bss inits
  19              	@  - call main instead for "RV runtime-init" __main
  20              	@  - call main with bx so it can be thumb-code
  21              	@  - added IRQ-Wrapper for easier porting of IAR, RV etc. ISR-codes.
  22              	@  - TargetResetInit can be a thumb-function (using BX instead of BL)
  23              	@  - moved TargetResetInit call before the stack-inits and use 
  24              	@    a temporary stack-pointer
  25              	
  26              	@@	PRESERVE8
  27              	
  28              	@/*
  29              	@ *  The STARTUP.S code is executed after CPU Reset. This file may be 
  30              	@ *  translated with the following SET symbols. In uVision these SET 
  31              	@ *  symbols are entered under Options - ASM - Define.
  32              	@ *
  33              	@ *  REMAP: when set the startup code initializes the register MEMMAP 
  34              	@ *  which overwrites the settings of the CPU configuration pins. The 
  35              	@ *  startup and interrupt vectors are remapped from:
  36              	@ *     0x00000000  default setting (not remapped)
  37              	@ *     0x40000000  when RAM_MODE is used
  38              	@ *
  39              	@ *  RAM_MODE: when set the device is configured for code execution
  40              	@ *  from on-chip RAM starting at address 0x40000000. 
  41              	@ */
  42              	
  43              	
  44              	@ Standard definitions of Mode bits and Interrupt (I & F) flags in PSRs
  45              	
  46              	.equ Mode_USR,            0x10
  47              	.equ Mode_FIQ,            0x11
  48              	.equ Mode_IRQ,            0x12
  49              	.equ Mode_SVC,            0x13
  50              	.equ Mode_ABT,            0x17
  51              	.equ Mode_UND,            0x1B
  52              	.equ Mode_SYS,            0x1F
  53              	
  54              	.equ I_Bit,               0x80            @ when I bit is set, IRQ is disabled
  55              	.equ F_Bit,               0x40            @ when F bit is set, FIQ is disabled
  56              	
  57              	
ARM GAS  crt0.S 			page 2


  58              	@// <h> Stack Configuration (Stack Sizes in Bytes)
  59              	@//   <o0> Undefined Mode      <0x0-0xFFFFFFFF:8>
  60              	@//   <o1> Supervisor Mode     <0x0-0xFFFFFFFF:8>
  61              	@//   <o2> Abort Mode          <0x0-0xFFFFFFFF:8>
  62              	@//   <o3> Fast Interrupt Mode <0x0-0xFFFFFFFF:8>
  63              	@//   <o4> Interrupt Mode      <0x0-0xFFFFFFFF:8>
  64              	@//   <o5> User/System Mode    <0x0-0xFFFFFFFF:8>
  65              	@// </h>
  66              	
  67              	.equ UND_Stack_Size,     0x00000000
  68              	.equ SVC_Stack_Size,     0x00000200
  69              	.equ ABT_Stack_Size,     0x00000000
  70              	.equ FIQ_Stack_Size,     0x00000000
  71              	.equ IRQ_Stack_Size,     0x00000100
  72              	.equ USR_Stack_Size,     0x00000000
  73              	
  74              	.equ Stack_Size,        (UND_Stack_Size + SVC_Stack_Size + ABT_Stack_Size + FIQ_Stack_Size + IRQ_St
  75              	
  76              	@@                AREA    STACK, NOINIT, READWRITE, ALIGN=3
  77              	@@
  78              	@@Stack_Mem       SPACE   Stack_Size
  79              	@@Stack_Top       EQU     Stack_Mem + Stack_Size
  80              	
  81              	.arm
  82              	.section .STACK, "w"
  83              	.align 3
  84              	Stack_Mem:
  85 0000 00000000 	.space Stack_Size
  85      00000000 
  85      00000000 
  85      00000000 
  85      00000000 
  86              	.equ Stack_Top, Stack_Mem + Stack_Size
  87              	
  88              	
  89              	@// <h> Heap Configuration
  90              	@//   <o>  Heap Size (in Bytes) <0x0-0xFFFFFFFF>
  91              	@// </h>
  92              	
  93              	@@Heap_Size       EQU     0x00000000
  94              	@@                AREA    HEAP, NOINIT, READWRITE, ALIGN=3
  95              	@@Heap_Mem        SPACE   Heap_Size
  96              	
  97              	.equ Heap_Size,   0x00000000
  98              	.section .HEAP, "w"
  99              	.align 3
 100              	HeapMem:
 101              	.if (Heap_Size>0)
 102              	.space Heap_Size
 103              	.endif
 104              	
 105              	
 106              	@ Area Definition and Entry Point
 107              	@  Startup Code must be linked first at Address at which it expects to run.
 108              	
 109              	@@                AREA    RESET, CODE, READONLY
 110              	@@                ARM
ARM GAS  crt0.S 			page 3


 111              	.section .RESET, "ax"
 112              	.arm
 113              	
 114              	@ Exception Vectors
 115              	@  Mapped to Address 0.
 116              	@  Absolute addressing mode must be used.
 117              	@  Dummy Handlers are implemented as infinite loops which can be modified.
 118              	
 119 0000 18F09FE5 	Vectors:        LDR     PC, Reset_Addr         
 120 0004 18F09FE5 	                LDR     PC, Undef_Addr
 121 0008 18F09FE5 	                LDR     PC, SWI_Addr
 122 000c 18F09FE5 	                LDR     PC, PAbt_Addr
 123 0010 18F09FE5 	                LDR     PC, DAbt_Addr
 124 0014 0000A0E1 	                NOP                            @ Reserved Vector 
 125              	@@                LDR     PC, IRQ_Addr
 126 0018 20F11FE5 	                LDR     PC, [PC, #-0x0120]     @ Vector from VicVectAddr
 127 001c 18F09FE5 	                LDR     PC, FIQ_Addr
 128              	
 129 0020 54000000 	Reset_Addr:      .word     Reset_Handler
 130 0024 40000000 	Undef_Addr:      .word     Undef_Handler
 131 0028 44000000 	SWI_Addr:        .word     SWI_Handler
 132 002c 48000000 	PAbt_Addr:       .word     PAbt_Handler
 133 0030 4C000000 	DAbt_Addr:       .word     DAbt_Handler
 134 0034 286E20B9 	                 .word     0xB9206E28             @ Reserved Address 
 135 0038 E0000000 	IRQ_Addr:        .word     IRQ_Handler
 136 003c 50000000 	FIQ_Addr:        .word     FIQ_Handler
 137              	
 138 0040 FEFFFFEA 	Undef_Handler:   B       Undef_Handler
 139 0044 FEFFFFEA 	SWI_Handler:     B       SWI_Handler
 140 0048 FEFFFFEA 	PAbt_Handler:    B       PAbt_Handler
 141 004c FEFFFFEA 	DAbt_Handler:    B       DAbt_Handler
 142              	@@ handled thru assembler wrapper (see below)
 143              	@@ IRQ_Handler:    B       IRQ_Handler
 144 0050 FEFFFFEA 	FIQ_Handler:     B       FIQ_Handler
 145              	
 146              	
 147              	@ Reset Handler
 148              	@                EXPORT  Reset_Handler
 149              	.global Reset_handler
 150              	Reset_Handler:
 151              	
 152              	@  Call low-level init C-function
 153              	@                IMPORT TargetResetInit
 154              	@                BL   TargetResetInit
 155              	
 156              	@ handled in application
 157              	@                 .extern TargetResetInit
 158              	@                 ldr     SP, =Stack_Top    @ temporary stack at Stack_Top
 159              	@                 LDR R0, =TargetResetInit
 160              	@                 MOV LR, PC
 161              	@                 BX R0
 162              	
 163              	
 164              	@  Setup Stack for each mode
 165 0054 C8009FE5 	                LDR     R0, =Stack_Top
 166              	
 167              	@  Enter Undefined Instruction Mode and set its Stack Pointer
ARM GAS  crt0.S 			page 4


 168 0058 DBF021E3 	                MSR     CPSR_c, #Mode_UND | I_Bit | F_Bit
 169 005c 00D0A0E1 	                MOV     SP, R0
 170 0060 000040E2 	                SUB     R0, R0, #UND_Stack_Size
 171              	
 172              	@  Enter Abort Mode and set its Stack Pointer
 173 0064 D7F021E3 	                MSR     CPSR_c, #Mode_ABT | I_Bit | F_Bit
 174 0068 00D0A0E1 	                MOV     SP, R0
 175 006c 000040E2 	                SUB     R0, R0, #ABT_Stack_Size
 176              	
 177              	@  Enter FIQ Mode and set its Stack Pointer
 178 0070 D1F021E3 	                MSR     CPSR_c, #Mode_FIQ | I_Bit | F_Bit
 179 0074 00D0A0E1 	                MOV     SP, R0
 180 0078 000040E2 	                SUB     R0, R0, #FIQ_Stack_Size
 181              	
 182              	@  Enter IRQ Mode and set its Stack Pointer
 183 007c D2F021E3 	                MSR     CPSR_c, #Mode_IRQ | I_Bit | F_Bit
 184 0080 00D0A0E1 	                MOV     SP, R0
 185 0084 010C40E2 	                SUB     R0, R0, #IRQ_Stack_Size
 186              	
 187              	@  Enter Supervisor Mode and set its Stack Pointer
 188 0088 D3F021E3 	                MSR     CPSR_c, #Mode_SVC | I_Bit | F_Bit
 189 008c 00D0A0E1 	                MOV     SP, R0
 190 0090 02AC4DE2 	                SUB     SL, SP, #SVC_Stack_Size
 191              	@                SUB     R0, R0, #SVC_Stack_Size
 192              	@leave in Supervisor Mode with Interrupts disabled
 193              	
 194              	@
 195              	@  Enter User Mode and set its Stack Pointer
 196              	@                MSR     CPSR_c, #Mode_USR
 197              	@                MOV     SP, R0
 198              	@                SUB     SL, SP, #USR_Stack_Size
 199              	
 200              	#ifdef ROM_RUN
 201              	@  Relocate .data section (Copy from ROM to RAM)
 202 0094 8C109FE5 	                LDR     R1, =_etext 
 203 0098 8C209FE5 	                LDR     R2, =_data 
 204 009c 8C309FE5 	                LDR     R3, =_edata 
 205 00a0 030052E1 	                CMP     R2, R3
 206 00a4 0300000A 	                BEQ     DataIsEmpty
 207 00a8 030052E1 	LoopRel:        CMP     R2, R3 
 208 00ac 04009134 	                LDRLO   R0, [R1], #4 
 209 00b0 04008234 	                STRLO   R0, [R2], #4 
 210 00b4 FBFFFF3A 	                BLO     LoopRel 
 211              	DataIsEmpty:
 212              	#endif
 213              	 
 214              	@  Clear .bss section (Zero init)
 215 00b8 0000A0E3 	                MOV     R0, #0 
 216 00bc 70109FE5 	                LDR     R1, =__bss_start__ 
 217 00c0 70209FE5 	                LDR     R2, =__bss_end__ 
 218 00c4 020051E1 	                CMP     R1,R2
 219 00c8 0200000A 	                BEQ     BSSIsEmpty
 220 00cc 020051E1 	LoopZI:         CMP     R1, R2 
 221 00d0 04008134 	                STRLO   R0, [R1], #4 
 222 00d4 FCFFFF3A 	                BLO     LoopZI 
 223              	BSSIsEmpty:
 224              	
ARM GAS  crt0.S 			page 5


 225              	
 226              	@  Enter the C code
 227              	@                IMPORT  __main
 228              	@                LDR     R0, =__main
 229              	                .extern main
 230 00d8 5C009FE5 	                LDR R0, =main
 231 00dc 10FF2FE1 	                BX      R0
 232              	
 233              	
 234              	@ User Initial Stack & Heap (not used in GNU port)
 235              	@@                AREA    |.text|, CODE, READONLY
 236              	
 237              	@@                IMPORT  __use_two_region_memory
 238              	@@                EXPORT  __user_initial_stackheap
 239              	@@__user_initial_stackheap
 240              	
 241              	@@                LDR     R0, =  Heap_Mem
 242              	@@                LDR     R1, =(Stack_Mem + USR_Stack_Size)
 243              	@@                LDR     R2, = (Heap_Mem +      Heap_Size)
 244              	@@                LDR     R3, = Stack_Mem
 245              	@@                BX      LR
 246              	
 247              	
 248              	@@ IRQ_Wrapper based on Examples for
 249              	@@ AT91-ARM7TDMI AIC from Atmel,
 250              	@@ adapted to LPC23xx/24xx VIC by M. Thomas
 251              	@@ This wrapper avoids compiler-dependencies.
 252              	
 253              	.set LPC_BASE_VIC, 0xFFFFF000
 254              	.set VIC_VectAddr, 0xF00
 255              	
 256              	.arm
 257              	IRQ_Handler:
 258              	
 259              	@- Manage Exception Entry
 260              	@- Adjust and save LR_irq in IRQ stack
 261 00e0 04E04EE2 	            sub         lr, lr, #4
 262 00e4 00402DE9 	            stmfd       sp!, {lr}
 263              	
 264              	@- Save SPSR need to be saved for nested interrupt
 265 00e8 00E04FE1 	            mrs         r14, SPSR
 266 00ec 00402DE9 	            stmfd       sp!, {r14}
 267              	
 268              	@- Save and r0 in IRQ stack
 269 00f0 01002DE9 	            stmfd       sp!, {r0}
 270              	
 271              	@- Load the ISR-Address from VICVectAddr
 272 00f4 44E09FE5 	            ldr         r14, =LPC_BASE_VIC
 273 00f8 000F9EE5 	            ldr         r0 , [r14, #VIC_VectAddr]
 274              	
 275              	@- Enable Interrupt and Switch in Supervisor Mode
 276 00fc 13F021E3 	           msr         CPSR_c, #Mode_SVC
 277              	
 278              	@- Save scratch/used registers and LR in User Stack
 279 0100 0E502DE9 	            stmfd       sp!, { r1-r3, r12, r14 }
 280              	
 281              	@- Branch to the routine pointed by the VIC_VectAddr
ARM GAS  crt0.S 			page 6


 282 0104 0FE0A0E1 	            mov         r14, pc
 283 0108 10FF2FE1 	            bx          r0
 284              	
 285              	@- Restore scratch/used registers and LR from User Stack
 286 010c 0E50BDE8 	            ldmia       sp!, { r1-r3, r12, r14 }
 287              	
 288              	@- Disable Interrupt and switch back in IRQ mode
 289 0110 92F021E3 	            msr         CPSR_c, #I_Bit | Mode_IRQ
 290              	
 291              	@-  Mark the End of Interrupt on the VIC
 292              	@   by writing to VICVectAddr - not needed 
 293              	@   here since already done in the ISRs
 294              	@@           ldr         r14, =LPC_BASE_VIC
 295              	@@           str         r14, [r14, #VIC_VectAddr]
 296              	
 297              	@- Restore R0
 298 0114 0100BDE8 	            ldmia       sp!, {r0}
 299              	
 300              	@- Restore SPSR_irq and r0 from IRQ stack
 301 0118 0040BDE8 	            ldmia       sp!, {r14}
 302 011c 0EF06FE1 	            msr         SPSR_cxsf, r14
 303              	
 304              	@- Restore adjusted  LR_irq from IRQ stack directly in the PC
 305 0120 0080FDE8 	            ldmia       sp!, {pc}^
 306              	
 307              	
 308              	@                END
 309 0124 00030000 	.end
 309      00000000 
 309      00000000 
 309      00000000 
 309      00000000 
ARM GAS  crt0.S 			page 7


DEFINED SYMBOLS
              crt0.S:46     *ABS*:00000010 Mode_USR
              crt0.S:47     *ABS*:00000011 Mode_FIQ
              crt0.S:48     *ABS*:00000012 Mode_IRQ
              crt0.S:49     *ABS*:00000013 Mode_SVC
              crt0.S:50     *ABS*:00000017 Mode_ABT
              crt0.S:51     *ABS*:0000001b Mode_UND
              crt0.S:52     *ABS*:0000001f Mode_SYS
              crt0.S:54     *ABS*:00000080 I_Bit
              crt0.S:55     *ABS*:00000040 F_Bit
              crt0.S:67     *ABS*:00000000 UND_Stack_Size
              crt0.S:68     *ABS*:00000200 SVC_Stack_Size
              crt0.S:69     *ABS*:00000000 ABT_Stack_Size
              crt0.S:70     *ABS*:00000000 FIQ_Stack_Size
              crt0.S:71     *ABS*:00000100 IRQ_Stack_Size
              crt0.S:72     *ABS*:00000000 USR_Stack_Size
              crt0.S:74     *ABS*:00000300 Stack_Size
              crt0.S:81     .text:00000000 $a
              crt0.S:84     .STACK:00000000 Stack_Mem
              crt0.S:84     .STACK:00000300 Stack_Top
              crt0.S:97     *ABS*:00000000 Heap_Size
              crt0.S:100    .HEAP:00000000 HeapMem
              crt0.S:112    .RESET:00000000 $a
              crt0.S:119    .RESET:00000000 Vectors
              crt0.S:129    .RESET:00000020 Reset_Addr
              crt0.S:130    .RESET:00000024 Undef_Addr
              crt0.S:131    .RESET:00000028 SWI_Addr
              crt0.S:132    .RESET:0000002c PAbt_Addr
              crt0.S:133    .RESET:00000030 DAbt_Addr
              crt0.S:136    .RESET:0000003c FIQ_Addr
              crt0.S:129    .RESET:00000020 $d
              crt0.S:150    .RESET:00000054 Reset_Handler
              crt0.S:138    .RESET:00000040 Undef_Handler
              crt0.S:139    .RESET:00000044 SWI_Handler
              crt0.S:140    .RESET:00000048 PAbt_Handler
              crt0.S:141    .RESET:0000004c DAbt_Handler
              crt0.S:135    .RESET:00000038 IRQ_Addr
              crt0.S:257    .RESET:000000e0 IRQ_Handler
              crt0.S:144    .RESET:00000050 FIQ_Handler
              crt0.S:138    .RESET:00000040 $a
              crt0.S:211    .RESET:000000b8 DataIsEmpty
              crt0.S:207    .RESET:000000a8 LoopRel
              crt0.S:223    .RESET:000000d8 BSSIsEmpty
              crt0.S:220    .RESET:000000cc LoopZI
              crt0.S:253    *ABS*:fffff000 LPC_BASE_VIC
              crt0.S:254    *ABS*:00000f00 VIC_VectAddr
              crt0.S:309    .RESET:00000124 $d

UNDEFINED SYMBOLS
Reset_handler
_etext
_data
_edata
__bss_start__
__bss_end__
main
